# -*- coding: utf-8 -*-
"""API OpenWeatherMap.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QG3JNEf2Xaehd9b_XNt4pskmt9GgxpiE

# Application : Meteo en ligne via l’API de OpenWeatherMap
OpenWeatherMap est un service en ligne qui fournit des données météorologiques, y compris des données météorologiques actuelles, des prévisions et des données historiques aux développeurs de services Web et d'applications mobiles.
"""
from IPython.display import Image
from IPython.core.display import HTML
from cassandra.cluster import Cluster
from cassandra.auth import PlainTextAuthProvider
from datetime import date
from datetime import datetime

import os
import csv
from termcolor import colored, cprint
import pandas as pd
import json 
from pandas.io.json import json_normalize #package for flattening json in pandas df
import urllib.request
import datetime
import urllib
import warnings

"""Dans cet atelier, nous exploitions cette api afin d’extraire les données météorologique sous forme JSON et on le stocke dans un fichier CSV respectant un format bien défini.
#### Pour cela nous suivons les étapes suivantes
Depuis 2015, utiliser openweathermap nécessite de s'enregistrer. On s'authentifie ensuite en utilisant une clé. Chaque requête doit sonc être complétée par : &appid=XXXXX où XXX est la valeur de la clé à utiliser. Cette clé est disponible sur Updago.
Nous allons utiliser le service OpenWeatherMap pour récolter des prévisions météo. Ces prévisions pourront être resservies par un site Web, par exemple.
Le site http://openweathermap.org propose une API pour récolter les informations qu'il diffuse.
Prendre connaissance des possibilités de l'API
La page de documentation de l'API est accessible ici : http://openweathermap.org/api
#### Voici quelques exemples :
http://api.openweathermap.org/data/2.5/weather?q=Tunis,Tunisia&appid=XXX
Remplacez XXX par la clé API. Dans la suite, pensez à ajouter le champ appid=XXX.
Remplacer ?q=Tunis,Tunisia par la villes et le pays recherchés.
La commande weather employée ici indique que nous souhaitons obtenir les conditions météo actuelles.
Le résultat est par défaut fourni au format json. Dans le cas de la commande weather, voici les informations qui sont obtenues : Weather Data
Il y a bien sûr d'autres commandes disponibles, qu'on trouvera dans la documentation. Notez en particulier la commande forecast qui permet d'obtenir des prévisions.
## Outils Python
#### Accès à l'API
Comme indiqué dans le cours, nous allons utiliser Python pour interroger openweathermap. Le module requests sera utilisé à la place d'urllib

#### Chargement des modules importantes
"""



"""#### Configuration de API et genration de url d'accès à l'API
Définition d'un fonction qui prend en parametres id de la ville, la ville, le pays pour generer un url respectant l'appel de l'<b>API OpenWeatherMAP</b> et aussi configurer l'APPID recuperé après enregistrement sur le site.
En effet, l'accès à l'api est effectué soit en utilisant ID de la ville (Tunis) récuperé via la site ( https://openweathermap.org/city/2464470) ou via un fichier json conteant la liste des pays et leur villes accessible via http://bulk.openweathermap.org/sample/city.list.json.gz.
#### Accès direct avec ID Ville/Pays
*- http://api.openweathermap.org/data/2.5/weather?id=2464470&mode=json&units=metric&APPID
#### Accès avec recherche de Ville et Pays
*-  http://api.openweathermap.org/data/2.5/weather?q=Tunis,Tunisia&mode=json&units=metric&APPID

Il faut specifier aussi les données sous forme JSON ou XML et l'unité de temperature (°C,F).
Pour Fahrenheit, on utilise unité=imperial, pour Celsius, on utilise unité= metric, et  par defaut Kelvin. 
"""

def url_builder(city_id,city_name,country):
    user_api = '60cb4631b4aeb406c2f1fa75bf08dc36'  # Obtain yours form: http://openweathermap.org/
    unit = 'metric'  # For Fahrenheit use imperial, for Celsius use metric, and the default is Kelvin.
    if(city_name!=""):
        api = 'http://api.openweathermap.org/data/2.5/weather?q=' # "http://api.openweathermap.org/data/2.5/weather?q=Tunis,fr
        full_api_url = api + urllib.parse.quote(str(city_name)) +','+ urllib.parse.quote(str(country))+ '&mode=json&units=' + unit + '&APPID=' + user_api
    else:
        api = 'http://api.openweathermap.org/data/2.5/weather?id='     # Search for your city ID here: http://bulk.openweathermap.org/sample/city.list.json.gz
        full_api_url = api + str(city_id) + '&mode=json&units=' + unit + '&APPID=' + user_api
   
    return full_api_url

"""Maintenant on passe à definir une fonction qui permet de récuperer le fichier JSON a partir de cette URL en utilisant <b>urllib.request.urlopen()</b>, <b>str.read.decode('utf-8')</b> pour l'encodage et <b>json.load() </b>pour charger une structire <b>SJON</b> a partir des fichier"""

def data_fetch(full_api_url):
    print(full_api_url)
    url = urllib.request.urlopen(full_api_url)
    print(f"url : {url}")
    output = url.read().decode('utf-8')
    raw_api_dict = json.loads(output)
    url.close()
    return raw_api_dict

"""#### Gestion des dates
Le module datetime, qui doit être installé sur vos machines permet de manipuler les dates et les heures. En particulier, il permet de convertir un timestamp en date :
"""
ts = 1543219200.0
print(datetime.datetime.fromtimestamp(ts))

"""Toujour dans le module datetime, la méthode datetime.datetime.now() renvoie la date (et l'heure actuelle). On peut aussi construire une date comme ceci :

"""

d = datetime.datetime(year=2018, month=11,day=26, hour=9, minute=00)

"""Une date, obtenue ainsi ou avec now() peut être transformée en timestamp :"""

print(d.timestamp())

"""### Convertion et formatage de heure et date
Definir une fonction qui permet de convertir un timestamp en Heure de la forme HH:MM AM/PM
"""

def time_converter(time):
    converted_time = datetime.datetime.fromtimestamp(
        int(time)
    ).strftime('%I:%M %p')
    return converted_time

"""### Extraction des champs à partir des fichiers JSON 
Mainetant, nous avons besoins de creer une fonction <b>data_organizer</b> qui prend une structure json complexe et créee une dictionnaire de données
contenant les attributs suivants:
<b>
    
*-city : La ville
    
*-country: le pays

*-temp: Temperature actuelle

*-temp_max: Temperature temp_max

*-temp_min :Temperature Min 

*-humidity ; Humidité

*-pressure ; Pression

*-sky       : Etat de Ciel 

*-sunrise  : Lever du soleil  
 
 
*-sunset : Coucher du soleil 

*-wind : Vistesse de Vent

*-wind_deg

*-dt : Date

*-cloudiness : Nuageux

</b>

"""

def data_organizer(raw_api_dict):
    data = dict(
        city=raw_api_dict.get('name'),
        country=raw_api_dict.get('sys').get('country'),
        temp=raw_api_dict.get('main').get('temp'),
        temp_max=raw_api_dict.get('main').get('temp_max'),
        temp_min=raw_api_dict.get('main').get('temp_min'),
        humidity=raw_api_dict.get('main').get('humidity'),
        pressure=raw_api_dict.get('main').get('pressure'),
        sky=raw_api_dict['weather'][0]['main'],
        sunrise=time_converter(raw_api_dict.get('sys').get('sunrise')),
        sunset=time_converter(raw_api_dict.get('sys').get('sunset')),
        wind=raw_api_dict.get('wind').get('speed'),
        wind_deg=raw_api_dict.get('deg'),
        dt=time_converter(raw_api_dict.get('dt')),
        cloudiness=raw_api_dict.get('clouds').get('all')
    )
    print (data)
    return data

"""### Définition d'un fonction d'affichage de données en format lisible """

def data_output(data):
    m_symbol = '\xb0' + 'C'
    print('---------------------------------------')
    print('Current weather in: {}, {}:'.format(data['city'], data['country']))
    print(data['temp'], m_symbol, data['sky'])
    print('Max: {}, Min: {}'.format(data['temp_max'], data['temp_min']))
    print('')
    print('Wind Speed: {}, Degree: {}'.format(data['wind'], data['wind_deg']))
    print('Humidity: {}'.format(data['humidity']))
    print('Cloud: {}'.format(data['cloudiness']))
    print('Pressure: {}'.format(data['pressure']))
    print('Sunrise at: {}'.format(data['sunrise']))
    print('Sunset at: {}'.format(data['sunset']))
    print('')
    print('Last update from the server: {}'.format(data['dt']))

"""### Enregistrement des donnnées sous forme CSV
Maintenant on a besoin d'une fonction qui permet serialiser les données sous forme CSV

"""

def WriteCSV(data):
    pathFileCsv = os.path.isfile('./weatherOpenMap.csv') 

    if pathFileCsv == False:
        with open('weatherOpenMap.csv', 'w', newline="",  encoding="utf-8") as fw: 
            w = csv.DictWriter(fw, data.keys())
            w.writeheader()#écrire l'en-tête
            w.writerow(data)
    else:
        with open('weatherOpenMap.csv', 'a',newline="", encoding="utf-8") as fa:
            w = csv.DictWriter(fa, data.keys())
            w.writerow(data)

"""# Lecture du format CSV – Structure de dictionnaire"""

def  ReadCSV():
    try:
    #ouverture de fichier en mode lecture en specifiant le encodage
        with open("weatherOpenMap.csv",'r') as Fichier:
        #lecture – utilisation du parseur csv en specifiant délimiteur
            csv_contenu = csv.reader(Fichier,delimiter=",") 
            reader = csv.DictReader(Fichier)
            dic={}
            for row in reader:
                print (row['city'])
                dic.update(row)
            #fermeture du fichier avec la méthode close()
            Fichier.close()
            return dic
    except IOError:
        print("Fichier n'est pas trouvé")

"""# Recuperer des coordonnées des villes à partir de json avec pandas
  Maintenant on a besoin d'une fonction qui permet recuperer les coordonnées des villesd'un fichier JSON 
  
"""

#load json object

def getVilles():
    print(os.getcwd())
    with open('city.list.json', encoding="utf-8") as f:
        d = json.load(f)
        villes=pd.DataFrame(d)
        return villes

"""## Programme Principale"""

if __name__ == '__main__':

    villes=getVilles()

    df = villes[villes["country"]=="FR"]
    df = df.drop_duplicates(subset=['name'])
    df = df.reset_index(drop =True)

for i in range(len(df)):
    try:      
        city_name = df["name"][i]
        country= df["country"][i]
        city_id= df["id"][i]
  
        print(colored('Generation de l url ', 'red',attrs=['bold']))
        url=url_builder(city_id,city_name,country)
        print(url)
        
        #Invocation de l'API afin de recuperer les données
        print(colored('Invocation de l API afin de recuperer les données', 'red',attrs=['bold']))
        data=data_fetch(url)

        #Formatage des données
        print(colored('Formatage des donnée', 'red',attrs=['bold']))
        data_orgnized=data_organizer(data)

        #Affichage de données
        print(colored('Affichage de données ', 'red',attrs=['bold']))
        # data_output(data_orgnized)
        
        #Enregistrement des données à dans un fichier CSV 
        print(colored('Enregistrement des données à dans un fichier CSV ', 'green',attrs=['bold']))
        WriteCSV(data_orgnized)

        print(colored('Lecture des données à partir un fichier CSV ', 'green',attrs=['bold']))
        #Lecture des données a partir de fichier CSV 
        data=ReadCSV()
        print(colored('Affichage des données lues de CSV ', 'green',attrs=['bold']))
        #Affichage des données 
        data_output(data)
                    
    except IOError:
        print('no internet')


warnings.filterwarnings('ignore')
today = date.today()

CASSANDRA_HOST = ["cassandra"]
CASSANDRA_PORT = 9042
CASSANDRA_DB = "weather"
CASSANDRA_TABLE = "France"
CASSANDRA_LOGIN = "cassandra"
CASSANDRA_PWD = "cassandra"
auth_provider = PlainTextAuthProvider(username=CASSANDRA_LOGIN, password=CASSANDRA_PWD)

def pandas_factory(colnames, rows):
    return pd.DataFrame(rows, columns=colnames)
#on force ici a repecter le datframe de pandas lors de la recuperation des données
try:
    cluster = Cluster(protocol_version=3,contact_points=CASSANDRA_HOST,load_balancing_policy=None,port=CASSANDRA_PORT, auth_provider=auth_provider)
    session =cluster.connect()
    session.row_factory = pandas_factory
    print("Connection established")
except ValueError:
    print("Oops!  échec de connexion cluster.  Try again...")

#creation du key space
session.execute("CREATE KEYSPACE IF NOT EXISTS france WITH REPLICATION={'class':'SimpleStrategy','replication_factor':1};")

#Creation de type Covid
# session.execute("CREATE TYPE IF NOT EXISTS  France.villeType ( city text, country text, temp float, temp_max float,  temp_min float, humidity float, pressure float, sky text, sunrise float, sunset float, wind float, wind_deg float, dt date, cloudiness int);")
session.execute("CREATE TABLE IF NOT EXISTS  france.villes (city text, country text, temp float, temp_max float,  temp_min float, humidity float, pressure float, sky text, sunrise text, sunset text, wind float, cloudiness int, dt text, primary key (city));")

rows=session.execute('Select * from france.villes;')
df_results = rows._current_rows
# df_results.head()
# print(type(df_results))
# print(df_results.head())

session = cluster.connect('france')  
session.row_factory = pandas_factory
session.default_fetch_size = 10000000 #needed for large queries, otherwise driver will do pagination. Default is 50000.

query_insert="INSERT INTO france.villes  (city, country, temp, temp_max,temp_min, humidity,pressure, sky,sunrise, sunset,  wind,cloudiness,dt) VALUES ($${}$$, '{}', {}, {},{}, {}, {}, '{}','{}', '{}', {}, {},'{}');"

df_weather = pd.read_csv("./weatherOpenMap.csv", sep = ",")

for ct in df_weather.index:
     
    CQL_query = query_insert.format(df_weather["city"][ct].replace("'", ""),df_weather["country"][ct],df_weather['temp'][ct],\
                df_weather["temp_max"][ct],df_weather["temp_min"][ct],df_weather['humidity'][ct],df_weather["pressure"][ct],\
                df_weather["sky"][ct],df_weather['sunrise'][ct],df_weather['sunset'][ct],df_weather['wind'][ct],df_weather["cloudiness"][ct],\
                df_weather["dt"][ct]) 
    #print(CQL_query)
    #break
    # print(CQL_query)
    # break
    session.execute(CQL_query)

#Executer une requete pour tester
rows = session.execute('SELECT * FROM france.villes ; ')
df_countries = rows._current_rows
df_countries.head()
# print(df_weather.head())
print("traitement terminé")
cluster.shutdown()